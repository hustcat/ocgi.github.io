<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reference on OCGI</title><link>https://ocgi.github.io/zh/docs/reference/</link><description>Recent content in Reference on OCGI</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Copyright © 2021 The OCGI Authors</copyright><atom:link href="https://ocgi.github.io/zh/docs/reference/index.xml" rel="self" type="application/rss+xml"/><item><title>Carrier SDK</title><link>https://ocgi.github.io/zh/docs/reference/sdk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/reference/sdk/</guid><description>背景 一般来说，游戏后端server会缓存一些玩家状态数据。在自动弹性伸缩的时候，Carrier controller不能随意创建/删除GameServer。K8s提供的Statefulset，Deployment等workload在缩容、变更删除Pod时缺少与应用程序的确认。
而GameServer workload提供了一个简单的SDK，游戏后端server可以把当前的一些服务状态信息，通知到Carrier controller，用于Carrier controller在弹性伸缩、或者发布变更时，选择合适的副本进行删除。
Game server与SDK的关系 SDK-Server作为sidecar容器(由Carrier controller自动注入)，与GameServer容器，运行在同一个K8s pod。 GameServer可以通过SDK API访问SDK-Server。如果应用程序不想调用SDK API，可以配置相应的Webhook，由SDK-Server来调用Webhook。 SDK-Server连接K8s API，并更新GameServer CRD。 用户自定义Condition GameServer可以通过SDK API或者Webhook的方式，设置自定义Condition。
ReadinessGates kind: GameServer ... spec: readinessGates: - network.ocgi.dev/lb-ready status: conditions: - type: &amp;#34;network.ocgi.dev/lb-ready&amp;#34; status: &amp;#34;True&amp;#34; lastProbeTime: null lastTransitionTime: 2018-01-01T00:00:00Z 当Squad在变更时，需要保证所有ReadinessGates Condition都为True，Carrier controller才认为新的副本状态是Ready。
DeletableGates kind: GameServer ... spec: deletableGates: - carrier.ocgi.dev/has-no-player status: conditions: - type: &amp;#34;carrier.ocgi.dev/has-no-player&amp;#34; status: &amp;#34;True&amp;#34; lastProbeTime: null lastTransitionTime: 2018-01-01T00:00:00Z 当Squad在变更，或者缩容时，需要保证DeletableGates Condition都为True，才能删除相应的副本。
GameServer访问SDK Server SDK-Server启动后，会监听一个gRPC和一个HTTP端口，Carrier controller会将端口信息作为环境变量写到GameServer容器：</description></item><item><title>GPA Webhook示例</title><link>https://ocgi.github.io/zh/docs/reference/gpa_webhook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/reference/gpa_webhook/</guid><description>简介 GPA(GeneralPodAutoscaler)提供了基于Webhook的机制来实现Workload的自动伸缩。例如：
apiVersion: autoscaling.ocgi.dev/v1alpha1 kind: GeneralPodAutoscaler metadata: name: pa-squad namespace: default spec: maxReplicas: 8 minReplicas: 1 scaleTargetRef: apiVersion: carrier.ocgi.dev/v1alpha1 kind: Squad name: squad-example webhook: parameters: buffer: &amp;#34;2&amp;#34; service: name: gpa-webhook namespace: kube-system path: scale port: 8000 Webhook Server由用户自己实现，从而实现由用户来控制Workload的副本数量。
实现Webhook Server 这里 是一个针对Squad开发的Webhook Server示例。
Webhook Request and Response Webhook api 定义如下
// AutoscaleRequest defines the request to webhook autoscaler endpoint type AutoscaleRequest struct { // UID is used for tracing the request and response.</description></item></channel></rss>