<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Guides on OCGI</title><link>https://ocgi.github.io/zh/docs/guides/</link><description>Recent content in Guides on OCGI</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Copyright © 2021 The OCGI Authors</copyright><atom:link href="https://ocgi.github.io/zh/docs/guides/index.xml" rel="self" type="application/rss+xml"/><item><title>Squad介绍</title><link>https://ocgi.github.io/zh/docs/guides/squad_details/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/guides/squad_details/</guid><description>Squad 一个Squad控制器为GameServers和GameServerSets提供声明式的更新管理能力。用户可以通过描述Squad中的目标状态(例如副本数)，Squad控制器会按照一定的规则更改实际状态，最终使其达到期望的状态。
主要特点 管理一组GameServer 支持滚动更新发布 支持分批（灰度）发布 支持原地更新发布 支持资源自动弹性伸缩 Squad更新策略 Squad通过.spec.strategy来指定更新GameServer的策略。.spec.strategy.type可以是 Recreate、RollingUpdate、CanaryUpdate、或者InplaceUpdate，默认为RollingUpdate
Recreate策略 在创建GameServer前，所有现有的GameServer会被删除掉
RollingUpdate策略 在指定.spec.strategy.type为RollingUpdate时，还可以指定maxUnavailable 和 maxSurge 来控制滚动更过程
maxUnavailable：最大不可用GameServer数。是一个可选字段，用来指定更新过程中不可用的 GameServer 的个数上限。该值可以是绝对数字（例如，5），也可以是所需 GameServer 的百分比（例如，10%）。百分比值会转换成绝对数并去除小数部分。 如果 .spec.strategy.rollingUpdate.maxSurge 为 0，则此值不能为 0。 默认值为 25%
maxSurge: 最大GameServer创建数。是一个可选字段，用来指定可以创建的超出期望 GameServer 个数的 GameServer 数量。此值可以是绝对数（例如，5）或所需 GameServer 的百分比（例如，10%）。 如果 MaxUnavailable 为 0，则此值不能为 0。百分比值会通过向上取整转换为绝对数。 此字段的默认值为 25%。
例如：当此值为25%时，启动滚动更新后，会立即对新的 GameServerSet 扩容，同时保证新旧 GameServer 的总数不超过所需 GameServer 总数的 125%。一旦旧 GameServer 被杀死，新的 GameServerSet 可以进一步扩容， 同时确保更新期间的任何时候运行中的 GameServer 总数最多为所需 GameServer 总数的 125%</description></item><item><title>GeneralPodAutoscaler介绍</title><link>https://ocgi.github.io/zh/docs/guides/gpa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/guides/gpa/</guid><description>我们通过GeneralPodAutoscaler(GPA)进行Pod水平伸缩。GPA是基于K8s HPA（v2beta2 api）扩展开发的一个组件。
GPA 特点 不依赖于K8s版本，可以运行于K8s 1.8、1.9、1.19等版本，只需要集群支持CRD; 通过GPA的Provider， 可以支持更多外部数据源，包括kafka, redis等； 支持更多伸缩模式，灵活性、扩展性更强； GPA升级灵活，升级时不需要重启K8s核心组件。 设计 架构 GPA 基于HPA开发的通用Pod扩缩容组件，覆盖了HPA的所有功能。
External Metrics Provider 实现了外部资源的Provider, 可以支持自定义外部资源。
GPA和HPA之间的差异 以下内容为例： 一个workload使用HPA和GPA的yaml差异
HPA apiVersion: autoscaling/v2beta2 kind: HorizontalPodAutoscaler metadata: name: test spec: maxReplicas: 10 minReplicas: 2 metrics: - resource: name: cpu target: averageValue: 20 type: AverageValue type: Resource scaleTargetRef: apiVersion: carrier.ocgi.dev/v1alpha1 kind: Squad name: squad-example1 GPA apiVersion: autoscaling.ocgi.dev/v1alpha1 kind: GeneralPodAutoscaler metadata: name: test spec: maxReplicas: 10 minReplicas: 2 metric: ##difference metrics: - resource: name: cpu target: averageValue: 20 type: AverageValue type: Resource scaleTargetRef: apiVersion: carrier.</description></item><item><title>GameServer自动伸缩流程</title><link>https://ocgi.github.io/zh/docs/guides/autoscaling_flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/guides/autoscaling_flow/</guid><description>GameServer的autoscaling的详细流程如下：
Autoscaler controller根据GameServer的metric信息，计算Squad的合理副本数量； Carrier根据一定规则选择GameServer，然后设置Constraint，通知应用程序下线该副本； RoomAssign下线对应的GameServer，设置Condition offline=true，表示不再分配新的玩家到该GameServer； GameServer等到没有玩家之后，再设置Condition no-player=true； Carrier controller删除offline=true &amp;amp;&amp;amp; no-player=true的GameServer。 注意，上面的Condition，比如offline，no-player可由业务自己定义。</description></item><item><title>设置GamerServer缩容的优先级</title><link>https://ocgi.github.io/zh/docs/guides/squad-scaledown-priority/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/guides/squad-scaledown-priority/</guid><description>背景 一般来说，每个游戏服务器上的玩家数量会不同。当我们缩容时，可以选择用户玩家少的副本，进行删除。这样，可以让应用侧的缩容开销更小，同时，也可以提高底层资源的利用效率。
我们可以根据一些业务侧指标，给每个游戏服务器设置一定的优先级。缩容时，我们选择优先级低的副本删除。
核心方案 给GameServer增加carrier.ocgi.dev/gs-deletion-cost(int64) annotation， annotation可以由用户调用sdk加上，或者由我们的组件cost-server加上。
cost-server根据squad里指定的 carrier.ocgi.dev/gs-cost-metrics-name annotation 从metric server获取数据， 给gs加上carrier.ocgi.dev/gs-deletion-cost annotation。 如果GameServer未设置carrier.ocgi.dev/gs-deletion-cost 按照Int64 Max计算。 如果所有GameServer都未设置，进入原先的逻辑，优先选择节点上GameServer较少的节点上的进行缩容，或者按照创建时间最老进行缩容。 carrier controller，按照该值从小到大顺序排序， 缩容掉top N。
cost-server 简介 cost-serverwatch Squad的创建和更新； cost-server从名为carrier.ocgi.dev/gs-cost-metrics-name的annotation获取对应的metric名； 如果metric是cpu 或者 memory，cost-server将从metric server获取数据；如果是其余metric将从custom metric server获取数据； 最终的数据将会写到GameServer的annotation上，例如：carrier.ocgi. dev/gs-deletion-cost: &amp;quot;2101248000&amp;quot;； 使用方式 如果是使用cpu、memory等指标，用户用只需要在Squad上指定carrier.ocgi.dev/gs-cost-metrics-name； 如果用户需要使用自定义指标，如连接数等，用户可以采用以下2种方式之一： 给Squad加上carrier.ocgi.dev/gs-cost-metrics-name: 连接数, 该方式存在一定延迟 借助SDK的SetAnnotation方法, 给每个GameServer设置carrier.ocgi.dev/gs-deletion-cost 示例 使用cost-server自动给GameServer加cost
创建 squad # cat &amp;lt;&amp;lt;EOF | kubectl apply -f - apiVersion: carrier.</description></item></channel></rss>